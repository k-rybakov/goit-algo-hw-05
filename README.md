# goit-algo-hw-05

**Завдання 1. HashTable, метод delete**

H = HashTable(1)

H.insert("apple", 10) 

print(H.get('apple')) // 10

H.delete('apple')

print(H.get('apple')) // None


**Завдання 2. Двійковий пошук для відсортованого масиву з дробовими числами**

Функція binary_search була виконана з 2 аргументами: 

sorted_array [1.25, 3.77, 5, 7.07, 9, 11.33] та target = 10

В результаті ми отримили кортеж з кількостью ітерацій для пошуку та верхней межой:

(3, 11.33)


**Завдання 3. Порівняння алгоритмів Боєра-Мура, **Кнута-Морріса-Прата**, **Рабіна-Карпа****

Отримані результати:

Стаття 1:

Pattern Type: existing
Boyer-Moore Time: 0.0004538000000000042
Knuth-Morris-Pratt Time: 0.00144029999999995
Rabin-Karp Time: 0.003901500000000002

Pattern Type: random
Boyer-Moore Time: 0.0005105000000000248
Knuth-Morris-Pratt Time: 0.0015542000000000056
Rabin-Karp Time: 0.003923399999999966

---

Стаття 2:

Pattern Type: existing
Boyer-Moore Time: 0.0006820000000000159
Knuth-Morris-Pratt Time: 0.002157900000000046
Rabin-Karp Time: 0.005245300000000008

Pattern Type: random
Boyer-Moore Time: 0.0007068000000000074
Knuth-Morris-Pratt Time: 0.002076599999999984
Rabin-Karp Time: 0.00649600000000000

---

Висновки:

1. **Алгоритм Боєра-Мура** має найшвидшу швидкість виконання серед трьох алгоритмів для обох типів підрядків у обох статтях. Він ефективно використовує техніку пропуску символів для прискорення пошуку підрядка.
2. **Алгоритм Кнута-Морріса-Прата (KMP)** виявився на другому місці за швидкістю виконання для обох типів підрядків у обох статтях. Він використовує техніку префікс-функції для ефективного пошуку підрядка.
3. **Алгоритм Рабіна-Карпа** виявився на третьому місці за швидкістю виконання серед трьох алгоритмів для обох типів підрядків у обох статтях. Він використовує хеш-функцію для пошуку підрядка.
